/*
 * @author Thijs Scheepers <thijs@label305.com>
 * Copyright (c) 2013 Thijs Scheepers.
 *
 * This source is subject to the BSD License.
 * Please see the LICENSE file for more information.
 * All other rights reserved.
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 * PARTICULAR PURPOSE.
 * 
 */
package noot.compiler;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Stack;

import noot.assembly.Instruction;
import noot.assembly.InstructionBlock;
import noot.assembly.MemoryLocation;
import noot.ast.DeclarationNode;
import noot.ast.IdentifierNode;
import noot.exceptions.GeneratorException;

/**
 * The Class GeneratorHelper.
 * 
 * This Class is here to help the Antlr generated Generator to construct
 * the a of TAM instructions. This helper will deal with InstructionBlocks which
 * can be referenced and jumped to by label. It will also help dealing with addressing
 * memory locations for declared identifiers as well as helper registers.
 * 
 * To-Do: This class should eventually extend the ScopeHelper and override closeScope() and openScope()
 * to deal with the allocation and deallocation of memory on certain scopes. This however has been
 * attempted in commit: 919d9f945a but unsuccessful due to unexpected behavior from the POP instruction.
 */
public class GeneratorHelper {

	/** 
	 * The memory locations.
	 * 
	 * List of all currently allocated memory locations, the index of this list is used
	 * for address creation. Addresses can be accessed through addressOfMemoryLocation().
	 */
	private ArrayList<MemoryLocation> memoryLocations = new ArrayList<MemoryLocation>();

	/** 
	 * The instruction block stack.
	 * 
	 * At the end this will contain all instructions for the compiled program.
	 */
	private Stack<InstructionBlock> instructionBlockStack = new Stack<InstructionBlock>();

	/**
	 * Instantiates a new generator helper.
	 * 
	 * This will populate the instructionBlockStack with a new InstrucionBlock to access
	 * via currentBlock();
	 */
	public GeneratorHelper()
	{	
		instructionBlockStack.push(new InstructionBlock(0));
	}

	/**
	 * Create a new block and push it onto the instructionBlockStack.
	 * 
	 * This method will account for correct labeling of the instruction block.
	 * 
	 * @ensure currentBlock().size() == 0
	 */
	public void pushBlock()
	{
		if(this.instructionBlockStack.peek().size() > 0)
		{
			instructionBlockStack.push(new InstructionBlock(currentBlock().labelIdentifier + 1));
		}
	}

	/**
	 * Push instructions for printing a string.
	 * 
	 * This can be used to create helpful messages for the read statement like: "Enter integer:".
	 *
	 * @param s the string to create instructions for
	 */
	public void pushInstructionsForPrintingString(String s)
	{
		for (int i = 0; i < s.length(); i++)
		{
			char c = s.charAt(i);        
			currentBlock().push(new Instruction("LOADL",Integer.toString(c),"Loading character"));
			currentBlock().push(new Instruction("CALL","put","Print character"));
		}
	}

	/**
	 * Finalize and print instructions.
	 * 
	 * This method should be called when all the instructions have been pushed. So the program can
	 * be printed. This will add POP and HALT instructions for cleanup and print the result to System.out.
	 */
	public void finalizeAndPrintInstructions()
	{
		int pushCount = 0;
		for(InstructionBlock ib : instructionBlockStack)
		{
			for(Instruction in : ib)
				if(in.getInstruction().equals("PUSH")) pushCount ++;
		}

		currentBlock().push(new Instruction("POP",Integer.toString(pushCount),0));

		// Adding a nice creation date
		DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm");
		Date date = new Date();

		Instruction haltInstruction = new Instruction("HALT");
		haltInstruction.setComment("Generated by the Noot Compiler ("+dateFormat.format(date)+")");
		currentBlock().push(haltInstruction);

		// Push the last block, new block will be ignored since it has no instructions on it
		pushBlock();

		for(InstructionBlock block : instructionBlockStack)
		{
			for(Instruction instruction : block)
				System.out.print(instruction.toString());
		}
	}

	/**
	 * Declare a DeclarationNode.
	 * 
	 * This should be called to create the appropriate space on the stack to store an Identifier. A MemoryLocation will
	 * be added and you can access this location through addressOfIdentifier(IdentifierNode inode) where the inode has
	 * the same DeclarationNode as used here.
	 *
	 * @param declaration the declaration node
	 */
	public void declare(DeclarationNode declaration)
	{
		IdentifierNode in = declaration.getIdentifierNode();

		if(in == null) // Used for easy debugging an invalid AST
			throw new NullPointerException("Declaration on line " + declaration.getLine() + " does not have an identifer.");

		MemoryLocation ml = new MemoryLocation(declaration);
		memoryLocations.add(ml);

		currentBlock().push(new Instruction("PUSH","1","Declaring " + in.getNodeType() + " " + in.getText()));
	}

	/**
	 * Alloc helper register and return the memory location of it.
	 * 
	 * Get a new helper memory location to use with for example the print statement to store temporary values.
	 * This will also add instructions to create the appropriate space on the stack to store the helper register.
	 * 
	 * @return the new memory location
	 */
	public MemoryLocation allocHelperRegister()
	{
		currentBlock().push(new Instruction("PUSH","1","Pushing for helper register"));

		MemoryLocation ml = new MemoryLocation();
		memoryLocations.add(ml);

		return ml;
	}

	/**
	 * Get the address of the MemoryLocation for an Identifier.
	 * 
	 * This address should be used to access the value stored within the Identifier.
	 * A GeneratorException will be thrown if the Identifier has not been allocated.
	 *
	 * @param node the identifier node to get the address for
	 * @return the address to be used in instructions for example the LOAD instruction
	 * @throws GeneratorException the generator exception
	 */
	public String addressOfIdentifier(IdentifierNode node) throws GeneratorException
	{
		String result = null;
		int index = 0;

		for(MemoryLocation ml : memoryLocations)
		{
			DeclarationNode dc = ml.getDeclaration();

			if(dc != null && node.getDeclarationNode() == dc)
				result = index + "[SB]";

			index++;
		}

		if(result == null)
			throw new GeneratorException("MemoryLocation is not allocated");

		return result;

	}

	/**
	 * Get the address of a MemoryLocation.
	 *
	 * This address should be used to access the value stored within a helper register.
	 * A GeneratorException will be thrown if the MemoryLocation has not been allocated.
	 *
	 * @param ml the MemoryLocation
	 * @return the address to be used in instructions for example the LOAD instruction
	 * @throws GeneratorException the generator exception
	 */
	public String addressOfMemoryLocation(MemoryLocation ml) throws GeneratorException
	{
		String result = null;
		int index = 0;

		for(MemoryLocation mlr : memoryLocations)
		{
			if(mlr == ml) 
				result = index + "[SB]";

			index++;
		}

		if(result == null)
			throw new GeneratorException("MemoryLocation is not allocated");

		return result;
	}

	/**
	 * The last added instruction block.
	 * 
	 * This method should be used when pushing new instructions to the program. For example
	 * by currentBlock().push(Instruction i);
	 * 
	 * @ensure result != null
	 * @return the current instruction block
	 */
	public InstructionBlock currentBlock()
	{
		return instructionBlockStack.peek();
	}

}
